Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-03-31T23:38:28+08:00

====== tcp 出现rst情况整理 ======
Created 星期日 31 三月 2019

正常情况tcp四层握手关闭连接，rst基本都是异常情况，整理如下：

1. GFW 

2. 对方端口未打开，发生在连接建立

 　　如果端口打开，只是sync_backlog满了的话，sync简单被丢弃，表现为超时，而不会rst。

3. close Socket 时recv buffer 不为空

　　例如，客户端发了两个请求，服务器只从buffer 读取第一个请求处理完就关闭连接，tcp层认为数据没有正确提交到应用，使用rst关闭连接。

3. 移动链路

	  移动网络下，国内是有5分钟后就回收信令，也就是IM产品，如果心跳>5分钟后服务器再给客户端发消息，就会收到rst。也要查移动网络下IM 保持<5min 心跳。

4. 负载等设备

	  负载设备需要维护连接转发策略，长时间无流量，连接也会被清除，而且很多都不告诉两层机器，新的包过来时才通告rst。

　　 Apple push 服务也有这个问题，而且是不可预期的偶发性连接被rst；rst 前第一个消息write 是成功的，而第二条写才会告诉你连接被重置，

　　曾经被它折腾没辙，因此打开每2秒一次tcp keepalive，固定5分钟tcp连接回收，而且发现连接出错时，重发之前10s内消息。

5. SO_LINGER

	同第三条，默认SO_LINGER选项关闭， 直接丢弃未发送完毕的send buffer，并发送rst，业务上表示为对端数据未收到；建议打开，但在linger time 内仍然未将buffer发送完，那依然发送rst。

　 好像曾经测试过haproxy 某种配置下，会使用rst关闭连接，少了网络交互而且没有 TIME_WAIT 问题

 

6. 超过超时重传次数、网络暂时不可达

7. TIME_WAIT 状态

　　tw_recycle = 1 时，sync timestamps 比上次小时，会被rst

7. 设置 connect_timeout

	 应用设置了连接超时，sync 未完成时超时了，会发送rst终止连接。

8. 非正常包

　 连接已经关闭，seq 不正确等

9. keepalive 超时

	公网服务tcp keepalive 最好别打开；移动网络下会增加网络负担，切容易掉线；非移动网络核心ISP设备也不一定都支持keepalive，曾经也发现过广州那边有个核心节点就不支持。
10. 请求超时
	曾经遇到过这样一个情况:一个客户端连接服务器，connect返回-1并且error=EINPROGRESS。 直接telnet发现网络连接没有问题。ping没有出现丢包。用抓包工具查看，客户端是在收到服务器发出的SYN之后就莫名其妙的发送了RST。
	
	比如像下面这样：
	
	
	
	 
	有89、27两台主机。主机89向主机27发送了一个SYN，表示希望连接8888端口，主机27回应了主机89一个SYN表示可以连接。但是主机27却很不友好，莫名其妙的发送了一个RST表示我不想连接你了。
	
	后来经过排查发现，在主机89上的程序在建立了socket之后，用setsockopt的SO_RCVTIMEO选项设置了recv的超时时间为100ms。而我们看上面的抓包结果表示，从主机89发出SYN到接收SYN的时间多达110ms。（从15:01:27.799961到15:01:27.961886， 小数点之后的单位是微秒）。因此主机89上的程序认为接收超时，所以发送了RST拒绝进一步发送数据。. 
11. 提前关闭
	关于TCP，我想我们在教科书里都读到过一句话，'TCP是一种可靠的连接'。 而这可靠有这样一种含义，那就是操作系统接收到的来自TCP连接中的每一个字节，我都会让应用程序接收到。如果应用程序不接收怎么办？你猜对了，RST。
	
	看两段程序：
	
	这一段是server的最简单的代码。逻辑很简单，监听一个TCP端口然后当有客户端来连接的时候fork一个子进程来处理。注意看的是这一段fork里面的处理：

	char pcContent[4096];
	read(real_fd,pcContent,4096);
	close(real_fd);
	每次只是读socket的前4096个字节，然后就关闭掉连接。
	
	然后再看一下client的代码：

	这段代码更简单，就是打开一个socket然后连接一个服务器并发送5000个字节。刚才我们看服务器的代码，每次只接收4096个字节，那么就是说客户端发送的剩下的4个字节服务端的应用程序没有接收到，服务器端的socket就被关闭掉，这种情况下会发生什么状况呢，还是抓包看一看。
	
	 
	前三行就是TCP的3次握手，从第四行开始看，客户端的49660端口向服务器的9877端口发送了5000个字节的数据，然后服务器端发送了一个ACK进行了确认，紧接着服务器向客户端发送了一个RST断开了连接。和我们的预期一致。
	
13. 在一个已关闭的socket上收到数据

	如果某个socket已经关闭，但依然收到数据也会产生RST。
